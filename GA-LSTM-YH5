import time
import math
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.dates as mdates
from datetime import datetime
from keras.models import Sequential
from keras.layers import LSTM, Dense
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_squared_error, mean_absolute_error
from keras import backend as K

np.random.seed(1)  # Fix random seed for reproducibility/设定随机种子，保证实验可复现

class lstm():

    def __init__(self, dataset, hyper_params):
        self.dataset = dataset  # Initialize data sets/数据集初始化
        self.num_neur = hyper_params[0]  # Initialize number of layer and number of neurons in each layer/初始化隐层数和各层神经元个数
        self.look_back = hyper_params[1]  # Initialize length of windows/初始化窗口长度
        self.epochs = hyper_params[2]  # Initialize training times/初始化训练次数
        self.batch_size = hyper_params[3]  # Initialize batch size/初始化批数
        self.selected_feature = hyper_params[4]  # Initialize the selected features/初始化选择特征
        self.train_ratio = hyper_params[5]  # Initialize the splitted ratio of training/初始化训练集分割比例
        self.feature_num = hyper_params[6]  # Initialize the number of features/初始化特征数量
        self.x_train = []  # Initialize training features of training data set/初始化训练集x部分-训练特征
        self.y_train = []  # Initialize supervisory signals of training data set/初始化训练集y部分-监督信号
        self.x_test = []  # Initialize test features of training data set/初始化测试集x部分-测试特征
        self.y_test = []  # Initialize supervisory signals of training data set/初始化测试集y部分-监督信号

    # Split into train and test sets/分割训练集与测试集
    def split_dataset(self):
        # Feature selection/特征选择
        def feature_selection(selected_feature):
            selected_list = []
            for index, item in enumerate(selected_feature):
                if item == 1:
                    selected_list.append(index)
                else:
                    if index == 1:
                        selected_list.append(index)
            return selected_list

        # Convert an array of values into a dataset matrix/转换数据结构，准备训练集与测试集
        def create_dataset(dataset, look_back):
            dataX, dataY = [], []
            for i in range(len(dataset) - look_back):
                a = dataset[i:(i + look_back), 0:dataset.shape[1]]
                dataX.append(a)
                dataY.append(dataset[i + look_back, 0])
            return np.array(dataX), np.array(dataY)

        selected_list = feature_selection(self.selected_feature)  # Index list of selected feature/选择特征列表索引
        train_size = int(len(self.dataset) * self.train_ratio)  # Size of training data set/训练集大小
        train_data = self.dataset[0:train_size, selected_list]  # Training data set/训练集
        test_data = self.dataset[train_size - self.look_back - 1:len(self.dataset), selected_list]  # Test data set/测试集
        self.feature_num = len(selected_list)  # Update the number of selected feature/更新特征数量

        # Data set detail/具体分割后数据集
        x_train, self.y_train = create_dataset(train_data, self.look_back)
        x_test, self.y_test = create_dataset(test_data, self.look_back)

        # Reshape input to be [samples, feature_num, features]/整理特征数据的格式
        self.x_train = np.reshape(x_train, (x_train.shape[0], self.feature_num, x_train.shape[1]))
        self.x_test = np.reshape(x_test, (x_test.shape[0], self.feature_num, x_test.shape[1]))
        #print(self.x_test)
        #print(self.y_test)

    # Create and fit the LSTM network/创建并拟合LSTM网络
    def lstm(self):
        start_cr_a_fit_net = time.time()  # Record time/记录网络创建与训练时间
        self.split_dataset()  # Split the data set/数据分割

        # Create and fit the LSTM network/创建并拟合LSTM网络
        LSTM_model = Sequential()
        for i in range(len(self.num_neur)):  # 构建多层网络
            if len(self.num_neur) == 1:
                LSTM_model.add(LSTM(self.num_neur[i], input_shape=(None, self.look_back)))
            else:
                if i < len(self.num_neur) - 1:
                    LSTM_model.add(LSTM(self.num_neur[i], input_shape=(None, self.look_back),
                                        return_sequences=True))
                else:
                    LSTM_model.add(LSTM(self.num_neur[i], input_shape=(None, self.look_back)))

        LSTM_model.add(Dense(1)) #dense就是全连接层
        LSTM_model.summary()  # Summary the structure of neural network/网络结构总结
        LSTM_model.compile(loss='mean_squared_error', optimizer='adam')  # Compile the neural network/编译网络
        LSTM_model.fit(self.x_train, self.y_train, epochs=self.epochs, batch_size=self.batch_size
                       , verbose=0)  # Fit the LSTM network/拟合LSTM网络
        LSTM_model.save('QLmodel_sy_lstm.h5')
        end_cr_a_fit_net = time.time() - start_cr_a_fit_net
        print('Running time of creating and fitting the LSTM network: %.2f Seconds' % (end_cr_a_fit_net))

        # LSTM prediction/LSTM进行预测
        trainPredict = LSTM_model.predict(self.x_train)  # Predict by training data set/训练集预测
        testPredict = LSTM_model.predict(self.x_test)  # Predict by test data set/测试集预测
        return trainPredict, testPredict, self.y_train, self.y_test

    # Evaluate network performance/评估网络效果
    def mape(self, scaler, trainPredict, testPredict):
        # Invert predictions start / 将预测值转换为正常数值
        # Create empty table like the dataset/创建一个空的数组, 结构同dataset
        trainPredict_dataset_like = np.zeros(shape=(len(trainPredict), self.dataset.shape[1]))
        # Put the predicted values in the right field/将预测值填充进新建数组
        trainPredict_dataset_like[:, 0] = trainPredict[:, 0]
        # Inverse transform and then select the right field/数据转换
        trainPredict = scaler.inverse_transform(trainPredict_dataset_like)[:, 0]

        y_train_dataset_like = np.zeros(shape=(len(self.y_train), self.dataset.shape[1]))
        y_train_dataset_like[:, 0] = self.y_train
        self.y_train = scaler.inverse_transform(y_train_dataset_like)[:, 0]
        # 定义全局变量以方便观察训练集效果
        global train_y_real
        train_y_real = scaler.inverse_transform(y_train_dataset_like)[:, 0]

        testPredict_dataset_like = np.zeros(shape=(len(testPredict), self.dataset.shape[1]))
        testPredict_dataset_like[:, 0] = testPredict[:, 0]
        testPredict = scaler.inverse_transform(testPredict_dataset_like)[:, 0]
        #print(trainPredict)
        #print(testPredict)
        y_test_dataset_like = np.zeros(shape=(len(self.y_test), self.dataset.shape[1]))
        y_test_dataset_like[:, 0] = self.y_test
        self.y_test = scaler.inverse_transform(y_test_dataset_like)[:, 0]
        # Invert predictions end/数据转换结束

        # Calculate root mean squared error and MAPE/计算RMSE和误差率MAPE
        train_RMSE = math.sqrt(mean_squared_error(self.y_train, trainPredict))
        test_RMSE = math.sqrt(mean_squared_error(self.y_test, testPredict))
        #trainMAPE = np.mean(np.abs(self.y_train - trainPredict) / self.y_train)
        testMAPE = np.mean(np.abs(self.y_test - testPredict) / self.y_test)
        # 计算 MAE 和 MSE（ZX）
        train_MAE = mean_absolute_error(self.y_train, trainPredict)
        test_MAE = mean_absolute_error(self.y_test, testPredict)
        train_MSE = mean_squared_error(self.y_train, trainPredict)
        test_MSE = mean_squared_error(self.y_test, testPredict)

        # 输出结果(ZX)
        print("Train RMSE: " + str(round(train_RMSE, 2)))
        print("Test RMSE: " + str(round(test_RMSE, 2)))
        print("Train MAE: " + str(round(train_MAE, 2)))
        print("Test MAE: " + str(round(test_MAE, 2)))
        print("Train MSE: " + str(round(train_MSE, 2)))
        print("Test MSE: " + str(round(test_MSE, 2)))
        #print("Train RMSE: " + str(round(train_RMSE, 2)) + '  ' + "Train MAPE: " + str(round(trainMAPE * 100, 2)))
        #print("Test RMSE: " + str(round(test_RMSE, 2)) + '  ' + "Test MAPE: " + str(round(testMAPE * 100, 2)))
        return testMAPE, trainPredict, testPredict

    # Visualization results/可视化结果
    def plot(self, scaler, trainPredict, testPredict):
        # Shift training predictions for plotting/转换数据结构用于作图-训练预测结果
        sub_traindataset = [[data] for data in self.dataset[:, 0]]
        trainPredictPlot = np.empty_like(sub_traindataset)
        trainPredictPlot[:, 0] = np.nan
        trainPredictPlot[self.look_back:len(trainPredict) + self.look_back, 0] = trainPredict

        # Shift test predictions for plotting/转换数据结构用于作图-测试预测结果
        sub_testdataset = [[data] for data in self.dataset[:, 0]]
        testPredictPlot = np.empty_like(sub_testdataset)
        testPredictPlot[:] = np.nan
        testPredictPlot[len(trainPredict) + self.look_back - 1:len(self.dataset), 0] = testPredict

        # plot baseline and predictions/作图
        datasety_like = np.zeros(shape=(self.dataset.shape[0], self.dataset.shape[1]))
        datasety_like[:, 0] = self.dataset[:, 0]
        y = scaler.inverse_transform(datasety_like)[:, 0]

        dates = pd.date_range('1950-11', periods=len(y), freq='M')
        xs = [datetime.strptime(str(d)[0:7], '%Y-%m').date() for d in dates]
        # 配置横坐标
        plt.gca().xaxis.set_major_formatter(mdates.DateFormatter('%Y-%m'))
        plt.gca().xaxis.set_major_locator(mdates.MonthLocator(bymonth=[1, 7]))

        A, = plt.plot(xs, y[0:len(y)], linewidth='2', color='r')  # 真实值
        B, = plt.plot(xs, trainPredictPlot, linewidth='1.5', color='g')  # LSTM训练集结果
        C, = plt.plot(xs, testPredictPlot, linewidth='1.5', color='b')  # LSTM测试集结果

        # plt.plot(NpredYPlot,linewidth = '3',color='k')
        plt.axvline(xs[169], linewidth='2', color='black')  # 画直线区分训练部分与测试部分
        plt.legend((A, B, C), ('real_value', 'LSTM_train', 'LSTM_test'), loc='best')
        plt.gcf().autofmt_xdate()  # 自动旋转日期标记

        plt.xlabel('Date', family='Times New Roman', fontsize=16)  # X轴
        plt.ylabel('BRIDGE', family='Times New Roman', fontsize=16)  # Y轴

        plt.title('LSTM', family='Times New Roman', fontsize=16)  # 添加标题

        plt.savefig(r'lstm050.png', dpi=900)  # 保存图片

        plt.show()
        del trainPredictPlot, testPredictPlot

if __name__ == "__main__":
    # Load the dataset/导入数据集
    file = r'YH5data-1.xls'
    dataframe = pd.read_excel(file, sheet_name=0, header=0, index_col=None)
    dataset = dataframe.iloc[:, [1, 2, 3, 4, 5, 6, 7, 8]].values
    dataset = dataset.astype('float32')

    # 测试集数据
    y_test_1 = dataframe.iloc[4097:, 1].values  # y_valid_pd为训练集输出
    y_test_pd = pd.DataFrame(y_test_1)

    # Normalize the dataset/标准化数据集
    scaler = MinMaxScaler(feature_range=(0, 1))
    dataset = scaler.fit_transform(dataset)

    # Set hyper-parameters/设定超参数
    num_neur = [10,20,30]  # Number of layer and number of neurons in each layer/隐藏层数和各层神经元个数
    look_back = 1  # Length of windows/窗口长度
    epochs = 80 # Training times/训练次数
    batch_size = 64 # Batch size/批数大小
    select_feature = [1, 1, 1, 1, 1, 1, 1, 1]  # Selected features list/被选择特征列表
    train_ratio = 0.8  # Splitted ratio of training data set/训练集分割比例
    feature_num = dataset.shape[1]  # Feature number+y/特征数量+1,也将预测项作为特征
    print(feature_num)
    # Hyper-parameter list/超参数列表
    hyper_params = [num_neur, look_back, epochs, batch_size, select_feature, train_ratio, feature_num]

    # Start an LSTM model/开始一个LSTM网络
    model = lstm(dataset, hyper_params)  # Create instance of LSTM/实例化模型

    trainPredict, testPredict, y_train, y_test = model.lstm()  # Create and fit the LSTM network/创建并拟合LSTM网络
    testMAPE, trainPredict, testPredict = model.mape(scaler, trainPredict
                                                                , testPredict)  # Evaluate network performance/评估网络效果


#    tensorboard --logdir "d:/jupyter/deeplearning/keras_07/my_log_dir"
    K.clear_session()  # 关掉内存中神经网络

    y_test_arr = np.array(y_test_pd)
    y_test_arr = y_test_arr.ravel() #将测试集转换为1维进行运算
    def mean_relative_error(y_true, y_pred, ):
        relative_error = np.average(np.abs(y_true - y_pred) / y_true, axis=0)
        return relative_error
    print("平均相对误差：" + str(mean_relative_error(y_test_arr, testPredict, )))
    testMAPE = np.mean(np.abs(y_test_arr - testPredict) / y_test_arr)
    print("测试集预测平均相对误差：" + str(testMAPE))
    print(testPredict)
    print(testPredict.shape)

    from matplotlib.pylab import mpl
    mpl.rcParams['font.sans-serif'] = ['SimHei']  # 显示中文
    mpl.rcParams['axes.unicode_minus'] = False  # 显示负号

    plt.figure(figsize=(15, 6))
    bwith = 0.75  # 边框宽度设置为2
    ax = plt.gca()  # 获取边框
    ax.spines['bottom'].set_linewidth(bwith)
    ax.spines['left'].set_linewidth(bwith)
    ax.spines['top'].set_linewidth(bwith)
    ax.spines['right'].set_linewidth(bwith)
    plt.plot(trainPredict, label='predict')
    plt.plot(train_y_real, label='test')
    # plt.plot(train_y_real*(1+0.15),label='15%上限',linestyle='--',color='green')
    # plt.plot(train_y_real*(1-0.15),label='15%下限',linestyle='--',color='green')
    plt.legend()
    plt.show()

    plt.figure(figsize=(15, 6))
    bwith = 0.75  # 边框宽度设置为2
    ax = plt.gca()  # 获取边框
    ax.spines['bottom'].set_linewidth(bwith)
    ax.spines['left'].set_linewidth(bwith)
    ax.spines['top'].set_linewidth(bwith)
    ax.spines['right'].set_linewidth(bwith)
    plt.plot(testPredict, label='predict')
    plt.plot(y_test_pd, label='test')
    plt.legend()
    plt.show()

#将预测结果输出到Excel
testPredict = pd.DataFrame(testPredict)
writer = pd.ExcelWriter('predictdata.xls')
testPredict.to_excel(writer,'sheet_1',float_format='%.2f')
writer.save()
writer.close()
